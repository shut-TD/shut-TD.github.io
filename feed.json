{
    "version": "https://jsonfeed.org/version/1",
    "title": "shutTD",
    "subtitle": "Cyber AD",
    "icon": "https://shut-td.github.io/images/favicon.ico",
    "description": "菜只因~",
    "home_page_url": "https://shut-td.github.io",
    "items": [
        {
            "id": "https://shut-td.github.io/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/",
            "url": "https://shut-td.github.io/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/",
            "title": "CMD命令混淆",
            "date_published": "2024-04-02T16:53:28.000Z",
            "content_html": "<h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>当我们获取 shell 或者连接到远控时，直接执行高危操作会被拦截因此需要做命令上的混淆来达到静态免杀的效果。</p>\n<h5 id=\"1-转义符号连接\"><a class=\"anchor\" href=\"#1-转义符号连接\">#</a> 1、转义符号连接</h5>\n<p>即在命令中通过填充  ^  该符号进行混淆<br />\n <figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">w</span><span class=\"symbol\">^h</span><span class=\"symbol\">^o</span><span class=\"symbol\">^am</span><span class=\"symbol\">^i</span></span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hoczg4gntcj30dk02pglk.jpg\" alt=\"\" /><br />\n<strong> 注意这里一次只能用一个 ^ 进行连接</strong></p>\n<h5 id=\"2-利用set设置变量并使用连续执行达到混淆效果\"><a class=\"anchor\" href=\"#2-利用set设置变量并使用连续执行达到混淆效果\">#</a> 2、利用 set 设置变量并使用 &amp;&amp; 连续执行达到混淆效果</h5>\n<p><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> gg=wh&amp;&amp;<span class=\"built_in\">%gg</span><span class=\"built_in\">%oami</span></span><br><span class=\"line\">再加上<span class=\"number\">1</span>的操作</span><br><span class=\"line\"><span class=\"keyword\">set</span> gg=<span class=\"keyword\">w</span><span class=\"symbol\">^h</span>^&amp;&amp;<span class=\"built_in\">%gg</span><span class=\"built_in\">%oa</span><span class=\"symbol\">^mi</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hocznijn5cj30ei023weh.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hocznwfke0j30fq02jdfu.jpg\" alt=\"\" /></p>\n<h5 id=\"3-双引号包裹\"><a class=\"anchor\" href=\"#3-双引号包裹\">#</a> 3、双引号包裹</h5>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>wh<span class=\"string\">&quot;&quot;</span>o<span class=\"string\">&quot;ami&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;&quot;w&quot;&quot;&quot;</span><span class=\"string\">&quot;h^o&quot;</span><span class=\"string\">&quot;am^i</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoczp72g9fj30c202swef.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hoczplami2j30dw02et8o.jpg\" alt=\"\" /></p>\n<h5 id=\"4-括号包裹\"><a class=\"anchor\" href=\"#4-括号包裹\">#</a> 4、括号包裹</h5>\n<p><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((((((whoami))))))</span><br><span class=\"line\">混合有限只能中间和 ^ 配合</span><br><span class=\"line\">((((((<span class=\"keyword\">w</span><span class=\"symbol\">^h</span><span class=\"symbol\">^o</span><span class=\"symbol\">^a</span><span class=\"symbol\">^m</span><span class=\"symbol\">^i</span>))))))</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoczqr3468j30ea02et8p.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoczr5q7d6j30fg02kt8q.jpg\" alt=\"\" /></p>\n<h5 id=\"5-unicode替换非通用\"><a class=\"anchor\" href=\"#5-unicode替换非通用\">#</a> 5、Unicode 替换 (非通用)</h5>\n<p>ʱ ʰ ʲ ʳ ʷ ʸ ˢ ˣ ˡ<br />\nʷ 修饰字母小写 W<br />\nʸ 修饰字母小写 Y<br />\nʰ 修饰字母小写 H<br />\nʱ 带钩的修饰字母小写 H<br />\nʲ 修饰字母小写 J<br />\nʳ 修饰字母小写 R<br />\nˡ 修饰字母小写 L<br />\nˢ 修饰字母小写 S<br />\nˣ 修饰字母小写 X<br />\n 这个不太行，适用性太窄</p>\n<p>这也是我突发奇想试了将近半个多小时试出来总结出来的，结果上网一查早就有大佬总结好了 (emo 了～) 贴个链接把 ==&gt; <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvbmV0d29yay8yOTEwMjAuaHRtbA==\">https://www.freebuf.com/articles/network/291020.html</span></p>\n",
            "tags": [
                "攻防技巧",
                "攻防技巧"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98-CS%E4%BA%8C%E5%BC%80%E7%B3%BB%E5%88%97/",
            "url": "https://shut-td.github.io/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98-CS%E4%BA%8C%E5%BC%80%E7%B3%BB%E5%88%97/",
            "title": "源码反编译及搭建问题[CS二开系列]",
            "date_published": "2024-03-31T18:35:14.000Z",
            "content_html": "<h3 id=\"源码的反编译及搭建\"><a class=\"anchor\" href=\"#源码的反编译及搭建\">#</a> 源码的反编译及搭建</h3>\n<p>我这里使用的是 jadx 进行的反编译，因此后面会有一些代码上的坑需要注意一下。<br />\n新建如下图的目录结构，并将原始的 CSjar 包放进 cs_bin 即可。</p>\n<p><img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoaqyt5couj30me04874r.jpg\" alt=\"\" /></p>\n<p>使用 jadx 反编译完后导出为 graddle 项目至 cs_src 目录中即可获取源码即下图两个文件夹。</p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hoar1cl14pj30m8036mxd.jpg\" alt=\"\" /></p>\n<p>然后打开 IDEA 新建一个空项目并新建一个 decompiled_src 目录，并将 source 目录复制入 decompiled_src 即可，后续操作参考这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzM3ODUzMy5odG1s\">二开搭建</span>的文章。</p>\n<p>在这里主要讲下可能是 jadx 反编译的问题导致的反编译后的源代码有些地方会出错需要手动更正一下，这里举几个例子：<br />\n<img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hoar8i6pgnj30mv0a0wg6.jpg\" alt=\"\" /><br />\n这里报错的原型是这段代码：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry entry : <span class=\"built_in\">this</span>.hooks.entrySet())&#123;</span><br><span class=\"line\">\t.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这里只需要跟进 <code>this.hooks.entrySet()</code>  观察一下返回的类型是什么即可，比如这里跟进之后发现是个 Set 集合，在外面用 Set 集合封装一下在替换即可解决报错，需要注意的是泛型要对齐，再比如下图也是这样。<br />\n<img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoar8n7oogj30m20553ze.jpg\" alt=\"\" /></p>\n<p>还有一种报错就是属性报错，跟进那个类里看一下最接近的属性是什么改成什么就行了，还有包括一些明显的逻辑上的错误比如从外面接了参数却使用另一个赋值为空的参数去比较：<br />\n<img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoarg84tvzj30xq09s3zo.jpg\" alt=\"\" /><br />\n错误原型为第二行多加了 <code>String text2 = &quot;&quot;</code> ，并在 <code>sum += text.charAt(x)</code>  这段代码变成了 <code>sum += text2.charAt(x)</code>  修正过来即可，反正这类逻辑上的代码问题还是稍微注意一下就行。</p>\n<p>至此环境基本搭建完成，可以启动 Agressor 端进行相关例如 UI 的修改以及相关功能的二开了</p>\n",
            "tags": [
                "安全工具开发",
                "安全工具开发"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "url": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "title": "自我定位 & 未来展望 To Future~",
            "date_published": "2024-03-15T05:24:48.000Z",
            "content_html": "<h3 id=\"自我定位\"><a class=\"anchor\" href=\"#自我定位\">#</a> 自我定位</h3>\n<p>不多说上图<br />\n<img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrmbqbnrvj30q40q475r.jpg\" alt=\"\" /></p>\n<ul>\n<li>目前算是多方面发育吧，正在学习有关内核、驱动、逆向以及代审有关的知识。</li>\n<li>现在的想法主要还是朝着代码审计和安全开发走吧，目标暂时就是试着二开或者直接自研一整套 C2，审一审比较大的开源框架吧。</li>\n</ul>\n<h3 id=\"未来展望-to-future~\"><a class=\"anchor\" href=\"#未来展望-to-future~\">#</a> 未来展望 To Future~</h3>\n<p>可能更想去安全研究 / 实验室 / 攻防的岗位吧🙌</p>\n",
            "tags": []
        },
        {
            "id": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "url": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "title": "意外的Kernel32基址寻址",
            "date_published": "2024-03-15T03:03:18.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h3>\n<pre><code>在PE文件结构中有个十分重要的东西，也是杀软进行静态分析时常死盯着的，那就是我们的导入表(Import Directory)，内含了该文件运行时调用的DLL文件以及导出函数。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrid6mj92j31cx0tmgu8.jpg\" alt=\"\" /></p>\n<pre><code>如果我们编写脚本时使用Windows库内自带的API，那么这些DLL文件以及包含在内的导出函数便会一览无余得暴露出来，所以我们需要将这些都隐藏掉实现导入表隐藏。如何实现最重要的一步就是通过PEB找到我们的Kernel32基址。\n</code></pre>\n<h3 id=\"windbg调试中遇到的问题与解决\"><a class=\"anchor\" href=\"#windbg调试中遇到的问题与解决\">#</a> Windbg 调试中遇到的问题与解决</h3>\n<pre><code>Windbg的使用及安装教程网上资料很多就不多说了，主要提一下在调试时遇到的几个问题。\n1、在附加进程时出现错误，先尝试以管理员权限启动Windbg再附加，若仍然报错则直接File-&gt;Open Executable File直接启动任意一个可执行文件也是可以进行调试的，和附加是一样的。\n2、调试过程中发生错误 Symbol _PEB 不存在等等之类的，在符号搜索路径(Symbol File Path Search)中添加路径：SRV*c:\\mysymbol* http://msdl.microsoft.com/download/symbols 即可。\n3、查询至InloadOrderMudleList中的Flink，Blink双向链表时其地址为 ??? ，这是操作系统对内核数据结构的保护进行的隐藏，我分别在Win10，Win10(虚拟机)，Win11三台机器上操作发现只有Win10(虚拟机)进行了字段隐藏，只显示 ???，这个问题我也不知道怎么解决，看情况应该是只有虚拟机会出现，还望懂的大佬能帮一手。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnriy3p62qj30pf0a4q3t.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrjm8yshdj30nq09y409.jpg\" alt=\"\" /></p>\n<h3 id=\"kernel32基址寻址的两条路线\"><a class=\"anchor\" href=\"#kernel32基址寻址的两条路线\">#</a> Kernel32 基址寻址的两条路线</h3>\n<pre><code>如何使用Windbg在PEB寻找到kernel32基址这里不展开说了有很多相关的文章可以看，这里主要的内容是我在调试寻址过程中发现的一些问题。\n第一条路线：这是最常见的一条即通过InloadOrderMudleList:Flink这条链一直往下跟就能找到Kernel32的DllBase，汇编代码：\n</code></pre>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>:[<span class=\"number\">0x30</span>]     //找PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取Ldr</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取InloadOrderMudleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; xxx<span class=\"number\">.</span>exe</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; ntdll<span class=\"number\">.</span>dll</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x18</span>]  //获取kernel32 DLLBase也就是基地址</span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 第二条路线：在最先开始研究的时候我以为这条路线就是第一条路线，但随着调试的过程中发现这地址不对啊！我还以为是操作系统造成的区别导致地址不一，但是我运行了这两段代码都成功指向同一个地址也就是我们的 Kernel32 的基址<br />\n <figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>: [<span class=\"number\">0x30</span>]      //找到PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]    //找LDR</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x14</span>]    //InMemoryOrderModuleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;shellcode.exe&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;ntdll.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x10</span>]    //InInitializationOrderLinks:Flink =&gt; DllBase<span class=\"string\">&quot;kernel32.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 仔细观察上述两段寻址汇编会发现除了获取 Ldr 内的 MudleList 不同和最后不同，其他找的步骤都是一样，那我们看看两条路线在 Windbg 中最后分别是什么<br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrkh9hfh8j30yy07twgy.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrkhb2uquj30wn07vdhu.jpg\" alt=\"\" /></p>\n<pre><code>可以很明显看到这两个字段都指向了0x76fd0000，但是后面为什么InInitializationOrderLinks:Flink的地址就是Kernel32基址而不是DLLBase呢？根据网上众多资料收集来的信息来看可能是因为版本的原因造成的，其真正的基址需要在DllBase的地址上回滚8个字节(也就是图中从 0x18 ==&gt; 0x10)，所以才变成了Flink的地址。其中Ldr内三个模块都能找到Kernel32基址(除了上述两条还有InInitializationOrderModuleList)，只不过现在只有第一条路线是不需要回滚字节的。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrkqcctmbj30x30cftbx.jpg\" alt=\"\" /></p>\n<p><strong>至于要回滚字节的背后的底层原因我也不是很清楚，还请知道的大佬教教～～</strong></p>\n",
            "tags": [
                "Pwn",
                "Pwn"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "url": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "title": "给EXE上锁",
            "date_published": "2024-03-14T10:15:25.000Z",
            "content_html": "<pre><code>在免杀中我们常常会用各种加密手段将shellcode进行变形以达到绕过杀软的静态检测分析，比如说最常见的异或，base64编码，aes，rsa，ecc等，当然静态查杀并不是我们主要要解决的，因为静态查杀是最容易绕过的基本上用异或就可以解决，今天我们的主题是绕过杀软的动态查杀。\n先说说我认为的杀软查杀恶意文件的方法吧，第一种就是静态查杀，只通过搜索其有无恶意软件的静态特征进行查杀，这种是最容易绕过的基本上对恶意代码进行简单的变形就可以绕过了；第二种就是动态查杀，即用一个沙箱去模拟执行你的文件看是否会执行到某些敏感操作上去；第三种是内存查杀和行为监控，这也是最为难绕过的，因为不管你shellcode在执行前是什么样的加载到内存中去就会现出原形从而被检查到，还有在你去执行命令时不可避免的会向外联地址发送数据，这其中的流量特征也是难以更改的因此很容易被捕捉到，这也就是有些我们可以上线但一执行命令就寄了的原因。\n好，简单叙述完查杀原因，我们来步入今天的主题，如何轻松绕过第二种查杀。首先也是最为重要的一点，那就是我们的exe文件后面是可以跟参数的，举个例子：\n</code></pre>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;参数个数：%d&quot;</span>, argc);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第几个参数：%s-%s&quot;</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2u9hz3j30vp0pjwfe.jpg\" alt=\"\" /></p>\n<p>可以看到输出的参数，其中 argc 是命令行中参数个数 (包括了这个文件名)，其中 argv 中存储的是命令行中所有的参数。</p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2wjah4j30vn0plq4a.jpg\" alt=\"\" /></p>\n<p>既然可以跟参数取参数，那我们就可以像设置密码一样控制程序的流程，从而绕过某些检测机制。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InjectShellcode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Inject shellcode!!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((std::string)argv[<span class=\"number\">1</span>] == <span class=\"string\">&quot;123456&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">InjectShellcode</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Hello</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp2zdzbnj31bz0plt9l.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp315am2j30y60plmyf.jpg\" alt=\"\" /></p>\n<pre><code>最终效果如下：\n火绒：可持续上线不会掉\n360：可持续上线，可能长时间会掉\nwindef：可上线但执行不了命令(现在已经被标记了上不了线)\n卡巴斯基：可过静态无法上线\n</code></pre>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp35147bj31mf0mcwml.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp390367j31kp0koagt.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp3avk4jj30sg0qmju1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnqp3dngo0j30s80lsacp.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "免杀",
                "免杀"
            ]
        }
    ]
}