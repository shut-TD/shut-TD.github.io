{
    "version": "https://jsonfeed.org/version/1",
    "title": "shutTD",
    "subtitle": "Cyber AD",
    "icon": "https://shut-td.github.io/images/favicon.ico",
    "description": "菜只因~",
    "home_page_url": "https://shut-td.github.io",
    "items": [
        {
            "id": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "url": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "title": "自我定位 & 未来展望 To Future~",
            "date_published": "2024-03-15T05:24:48.000Z",
            "content_html": "<h3 id=\"自我定位\"><a class=\"anchor\" href=\"#自我定位\">#</a> 自我定位</h3>\n<p>不多说上图<br />\n<img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrmbqbnrvj30q40q475r.jpg\" alt=\"\" /></p>\n<ul>\n<li>doge)，咳咳开始说正经的，先自我介绍一下，一只在安全圈里苟着的老六，企业 SRC 排名没有，CTF 比赛也没打出什么亮眼的成绩 (双非弱校队友都凑不齐，不对连这个专业都没有～)，所以说还是挺艰难的，能一直坚持可能真的是因为热爱吧 (是不是有点尴尬😅)，从一直自学摸索到成立学校第一个安全实验室再到有幸到窑鸡服实习感觉还是挺爽的就是还不够，可能自己的期望更高吧。</li>\n<li>现在正在学习一些 Web，客户端的开发，内核，驱动和逆向相关的一些知识，还有代码审计和木马免杀，会尝试自研开发一套 C2，希望以后能在这些方向支楞起来吧🤭🤭🤭</li>\n</ul>\n<h3 id=\"未来展望-to-future~\"><a class=\"anchor\" href=\"#未来展望-to-future~\">#</a> 未来展望 To Future~</h3>\n<p>只希望在安全路上能越走越远就行，希望有朝一日能成为某个方向的领军人吧 (虽然好像听着在吹 b🤣🤣🤣)，希望每天都有人 V 我 50 哈哈哈😍😍😍</p>\n",
            "tags": []
        },
        {
            "id": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "url": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "title": "意外的Kernel32基址寻址",
            "date_published": "2024-03-15T03:03:18.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h3>\n<pre><code>在PE文件结构中有个十分重要的东西，也是杀软进行静态分析时常死盯着的，那就是我们的导入表(Import Directory)，内含了该文件运行时调用的DLL文件以及导出函数。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrid6mj92j31cx0tmgu8.jpg\" alt=\"\" /></p>\n<pre><code>如果我们编写脚本时使用Windows库内自带的API，那么这些DLL文件以及包含在内的导出函数便会一览无余得暴露出来，所以我们需要将这些都隐藏掉实现导入表隐藏。如何实现最重要的一步就是通过PEB找到我们的Kernel32基址。\n</code></pre>\n<h3 id=\"windbg调试中遇到的问题与解决\"><a class=\"anchor\" href=\"#windbg调试中遇到的问题与解决\">#</a> Windbg 调试中遇到的问题与解决</h3>\n<pre><code>Windbg的使用及安装教程网上资料很多就不多说了，主要提一下在调试时遇到的几个问题。\n1、在附加进程时出现错误，先尝试以管理员权限启动Windbg再附加，若仍然报错则直接File-&gt;Open Executable File直接启动任意一个可执行文件也是可以进行调试的，和附加是一样的。\n2、调试过程中发生错误 Symbol _PEB 不存在等等之类的，在符号搜索路径(Symbol File Path Search)中添加路径：SRV*c:\\mysymbol* http://msdl.microsoft.com/download/symbols 即可。\n3、查询至InloadOrderMudleList中的Flink，Blink双向链表时其地址为 ??? ，这是操作系统对内核数据结构的保护进行的隐藏，我分别在Win10，Win10(虚拟机)，Win11三台机器上操作发现只有Win10(虚拟机)进行了字段隐藏，只显示 ???，这个问题我也不知道怎么解决，看情况应该是只有虚拟机会出现，还望懂的大佬能帮一手。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnriy3p62qj30pf0a4q3t.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrjm8yshdj30nq09y409.jpg\" alt=\"\" /></p>\n<h3 id=\"kernel32基址寻址的两条路线\"><a class=\"anchor\" href=\"#kernel32基址寻址的两条路线\">#</a> Kernel32 基址寻址的两条路线</h3>\n<pre><code>如何使用Windbg在PEB寻找到kernel32基址这里不展开说了有很多相关的文章可以看，这里主要的内容是我在调试寻址过程中发现的一些问题。\n第一条路线：这是最常见的一条即通过InloadOrderMudleList:Flink这条链一直往下跟就能找到Kernel32的DllBase，汇编代码：\n</code></pre>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>:[<span class=\"number\">0x30</span>]     //找PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取Ldr</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取InloadOrderMudleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; xxx<span class=\"number\">.</span>exe</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; ntdll<span class=\"number\">.</span>dll</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x18</span>]  //获取kernel32 DLLBase也就是基地址</span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 第二条路线：在最先开始研究的时候我以为这条路线就是第一条路线，但随着调试的过程中发现这地址不对啊！我还以为是操作系统造成的区别导致地址不一，但是我运行了这两段代码都成功指向同一个地址也就是我们的 Kernel32 的基址<br />\n <figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>: [<span class=\"number\">0x30</span>]      //找到PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]    //找LDR</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x14</span>]    //InMemoryOrderModuleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;shellcode.exe&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;ntdll.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x10</span>]    //InInitializationOrderLinks:Flink =&gt; DllBase<span class=\"string\">&quot;kernel32.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 仔细观察上述两段寻址汇编会发现除了获取 Ldr 内的 MudleList 不同和最后不同，其他找的步骤都是一样，那我们看看两条路线在 Windbg 中最后分别是什么<br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrkh9hfh8j30yy07twgy.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrkhb2uquj30wn07vdhu.jpg\" alt=\"\" /></p>\n<pre><code>可以很明显看到这两个字段都指向了0x76fd0000，但是后面为什么InInitializationOrderLinks:Flink的地址就是Kernel32基址而不是DLLBase呢？根据网上众多资料收集来的信息来看可能是因为版本的原因造成的，其真正的基址需要在DllBase的地址上回滚8个字节(也就是图中从 0x18 ==&gt; 0x10)，所以才变成了Flink的地址。其中Ldr内三个模块都能找到Kernel32基址(除了上述两条还有InInitializationOrderModuleList)，只不过现在只有第一条路线是不需要回滚字节的。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrkqcctmbj30x30cftbx.jpg\" alt=\"\" /></p>\n<p><strong>至于要回滚字节的背后的底层原因我也不是很清楚，还请知道的大佬教教～～</strong></p>\n",
            "tags": [
                "Pwn",
                "Pwn"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "url": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "title": "给EXE上锁",
            "date_published": "2024-03-14T10:15:25.000Z",
            "content_html": "<pre><code>在免杀中我们常常会用各种加密手段将shellcode进行变形以达到绕过杀软的静态检测分析，比如说最常见的异或，base64编码，aes，rsa，ecc等，当然静态查杀并不是我们主要要解决的，因为静态查杀是最容易绕过的基本上用异或就可以解决，今天我们的主题是绕过杀软的动态查杀。\n先说说我认为的杀软查杀恶意文件的方法吧，第一种就是静态查杀，只通过搜索其有无恶意软件的静态特征进行查杀，这种是最容易绕过的基本上对恶意代码进行简单的变形就可以绕过了；第二种就是动态查杀，即用一个沙箱去模拟执行你的文件看是否会执行到某些敏感操作上去；第三种是内存查杀和行为监控，这也是最为难绕过的，因为不管你shellcode在执行前是什么样的加载到内存中去就会现出原形从而被检查到，还有在你去执行命令时不可避免的会向外联地址发送数据，这其中的流量特征也是难以更改的因此很容易被捕捉到，这也就是有些我们可以上线但一执行命令就寄了的原因。\n好，简单叙述完查杀原因，我们来步入今天的主题，如何轻松绕过第二种查杀。首先也是最为重要的一点，那就是我们的exe文件后面是可以跟参数的，举个例子：\n</code></pre>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;参数个数：%d&quot;</span>, argc);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第几个参数：%s-%s&quot;</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2u9hz3j30vp0pjwfe.jpg\" alt=\"\" /></p>\n<p>可以看到输出的参数，其中 argc 是命令行中参数个数 (包括了这个文件名)，其中 argv 中存储的是命令行中所有的参数。</p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2wjah4j30vn0plq4a.jpg\" alt=\"\" /></p>\n<p>既然可以跟参数取参数，那我们就可以像设置密码一样控制程序的流程，从而绕过某些检测机制。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InjectShellcode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Inject shellcode!!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((std::string)argv[<span class=\"number\">1</span>] == <span class=\"string\">&quot;123456&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">InjectShellcode</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Hello</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp2zdzbnj31bz0plt9l.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp315am2j30y60plmyf.jpg\" alt=\"\" /></p>\n<pre><code>最终效果如下：\n火绒：可持续上线不会掉\n360：可持续上线，可能长时间会掉\nwindef：可上线但执行不了命令(现在已经被标记了上不了线)\n卡巴斯基：可过静态无法上线\n</code></pre>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp35147bj31mf0mcwml.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp390367j31kp0koagt.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp3avk4jj30sg0qmju1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnqp3dngo0j30s80lsacp.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "免杀",
                "免杀"
            ]
        }
    ]
}